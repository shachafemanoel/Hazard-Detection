<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ONNX Inference Test</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #1a1a1a; color: #fff; }
        .test-container { max-width: 800px; margin: 0 auto; }
        .test-section { background: #2a2a2a; padding: 20px; margin: 20px 0; border-radius: 8px; }
        .status { padding: 10px; margin: 10px 0; border-radius: 4px; }
        .success { background: #2d5a2d; border: 1px solid #4a934a; }
        .error { background: #5a2d2d; border: 1px solid #934a4a; }
        .warning { background: #5a5a2d; border: 1px solid #93934a; }
        .info { background: #2d2d5a; border: 1px solid #4a4a93; }
        button { background: #007cba; color: white; border: none; padding: 10px 20px; margin: 5px; border-radius: 4px; cursor: pointer; }
        button:hover { background: #005a87; }
        button:disabled { background: #444; cursor: not-allowed; }
        pre { background: #1a1a1a; padding: 15px; border-radius: 4px; overflow-x: auto; font-size: 12px; }
        .log { height: 200px; overflow-y: auto; background: #000; padding: 10px; border-radius: 4px; font-family: monospace; font-size: 12px; }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>üîß ONNX Inference Fix Testing</h1>
        
        <div class="test-section">
            <h2>Backend Connection Test</h2>
            <button onclick="testBackend()">Test Backend Health</button>
            <button onclick="testBackendInference()">Test Backend Inference</button>
            <div id="backend-status" class="status info">Click button to test backend...</div>
            <pre id="backend-result"></pre>
        </div>
        
        <div class="test-section">
            <h2>Frontend ONNX Test</h2>
            <button onclick="testONNXLoading()">Test ONNX Model Loading</button>
            <button onclick="testONNXInference()" id="inference-btn" disabled>Test ONNX Inference</button>
            <div id="onnx-status" class="status info">Click button to test ONNX...</div>
            <pre id="onnx-result"></pre>
        </div>
        
        <div class="test-section">
            <h2>System Diagnostics</h2>
            <button onclick="runDiagnostics()">Run Full Diagnostics</button>
            <div id="diagnostics-status" class="status info">Click button to run diagnostics...</div>
            <pre id="diagnostics-result"></pre>
        </div>
        
        <div class="test-section">
            <h2>Live Logs</h2>
            <button onclick="clearLogs()">Clear Logs</button>
            <div id="live-logs" class="log">Logs will appear here...</div>
        </div>
    </div>

    <script src="ort/ort.min.js"></script>
    <script>
        // Enhanced logging
        const originalLog = console.log;
        const originalError = console.error;
        const originalWarn = console.warn;
        
        function addToLiveLog(type, ...args) {
            const logElement = document.getElementById('live-logs');
            const timestamp = new Date().toLocaleTimeString();
            const message = args.map(arg => 
                typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)
            ).join(' ');
            
            const logEntry = document.createElement('div');
            logEntry.style.color = type === 'error' ? '#ff6b6b' : type === 'warn' ? '#ffa726' : '#4fc3f7';
            logEntry.textContent = `[${timestamp}] ${type.toUpperCase()}: ${message}`;
            
            logElement.appendChild(logEntry);
            logElement.scrollTop = logElement.scrollHeight;
        }
        
        console.log = function(...args) {
            originalLog.apply(console, args);
            addToLiveLog('log', ...args);
        };
        
        console.error = function(...args) {
            originalError.apply(console, args);
            addToLiveLog('error', ...args);
        };
        
        console.warn = function(...args) {
            originalWarn.apply(console, args);
            addToLiveLog('warn', ...args);
        };
        
        function clearLogs() {
            document.getElementById('live-logs').innerHTML = 'Logs cleared...';
        }
        
        function updateStatus(elementId, status, className) {
            const element = document.getElementById(elementId);
            element.textContent = status;
            element.className = `status ${className}`;
        }
        
        function updateResult(elementId, result) {
            document.getElementById(elementId).textContent = typeof result === 'object' ? 
                JSON.stringify(result, null, 2) : result;
        }
        
        // Backend tests
        async function testBackend() {
            updateStatus('backend-status', 'Testing backend connection...', 'info');
            
            try {
                const response = await fetch('http://localhost:8000/health');
                if (response.ok) {
                    const data = await response.json();
                    updateStatus('backend-status', '‚úÖ Backend is healthy and ready', 'success');
                    updateResult('backend-result', data);
                    console.log('‚úÖ Backend test passed:', data);
                } else {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
            } catch (error) {
                updateStatus('backend-status', `‚ùå Backend connection failed: ${error.message}`, 'error');
                updateResult('backend-result', error.stack);
                console.error('‚ùå Backend test failed:', error);
            }
        }
        
        async function testBackendInference() {
            updateStatus('backend-status', 'Testing backend inference...', 'info');
            
            try {
                // Create a test image blob
                const canvas = document.createElement('canvas');
                canvas.width = 640;
                canvas.height = 640;
                const ctx = canvas.getContext('2d');
                
                // Draw a simple test pattern
                ctx.fillStyle = '#333';
                ctx.fillRect(0, 0, 640, 640);
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(100, 100, 200, 200);
                
                const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.8));
                
                const formData = new FormData();
                formData.append('file', blob, 'test.jpg');
                
                const response = await fetch('http://localhost:8000/detect', {
                    method: 'POST',
                    body: formData
                });
                
                if (response.ok) {
                    const data = await response.json();
                    updateStatus('backend-status', `‚úÖ Backend inference successful: ${data.detections.length} detections`, 'success');
                    updateResult('backend-result', data);
                    console.log('‚úÖ Backend inference test passed:', data);
                } else {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
            } catch (error) {
                updateStatus('backend-status', `‚ùå Backend inference failed: ${error.message}`, 'error');
                updateResult('backend-result', error.stack);
                console.error('‚ùå Backend inference test failed:', error);
            }
        }
        
        // ONNX tests
        let session = null;
        
        async function testONNXLoading() {
            updateStatus('onnx-status', 'Testing ONNX model loading...', 'info');
            
            try {
                if (!window.ort) {
                    throw new Error('ONNX Runtime not loaded');
                }
                
                console.log('üîÑ Configuring ONNX Runtime...');
                
                // Configure ONNX Runtime
                ort.env.wasm.simd = true;
                ort.env.wasm.wasmPaths = './ort/';
                ort.env.wasm.numThreads = Math.min(navigator.hardwareConcurrency || 4, 4);
                ort.env.wasm.proxy = false;
                ort.env.wasm.initTimeout = 30000;
                
                const EPs = [];
                if (ort.env.webgl?.isSupported) {
                    EPs.push('webgl');
                    console.log('‚úÖ WebGL execution provider available');
                }
                EPs.push('wasm');
                console.log('‚úÖ WASM execution provider available');
                
                console.log('üîÑ Loading model...');
                const modelPath = './object_detecion_model/model_18_7.onnx';
                
                session = await ort.InferenceSession.create(modelPath, {
                    executionProviders: EPs,
                    graphOptimizationLevel: 'all',
                    executionMode: 'sequential',
                    enableCpuMemArena: true,
                    enableMemPattern: true,
                    logId: 'test-model',
                    logSeverityLevel: 0
                });
                
                const modelInfo = {
                    inputNames: session.inputNames,
                    outputNames: session.outputNames,
                    executionProviders: EPs
                };
                
                updateStatus('onnx-status', '‚úÖ ONNX model loaded successfully', 'success');
                updateResult('onnx-result', modelInfo);
                document.getElementById('inference-btn').disabled = false;
                console.log('‚úÖ ONNX loading test passed:', modelInfo);
                
            } catch (error) {
                updateStatus('onnx-status', `‚ùå ONNX model loading failed: ${error.message}`, 'error');
                updateResult('onnx-result', error.stack);
                console.error('‚ùå ONNX loading test failed:', error);
            }
        }
        
        async function testONNXInference() {
            if (!session) {
                updateStatus('onnx-status', '‚ùå Model not loaded', 'error');
                return;
            }
            
            updateStatus('onnx-status', 'Testing ONNX inference...', 'info');
            
            try {
                // Create test input tensor
                const inputSize = 720;
                const inputData = new Float32Array(3 * inputSize * inputSize);
                
                // Fill with test pattern
                for (let i = 0; i < inputData.length; i++) {
                    inputData[i] = Math.random() * 0.5; // Random values between 0 and 0.5
                }
                
                const inputTensor = new ort.Tensor('float32', inputData, [1, 3, inputSize, inputSize]);
                const inputName = session.inputNames[0];
                
                console.log('üöÄ Running inference...');
                const startTime = performance.now();
                
                const results = await session.run({ [inputName]: inputTensor });
                
                const inferenceTime = Math.round(performance.now() - startTime);
                
                const outputName = Object.keys(results)[0];
                const outputTensor = results[outputName];
                
                const inferenceInfo = {
                    inferenceTime: `${inferenceTime}ms`,
                    inputShape: inputTensor.dims,
                    outputShape: outputTensor.dims,
                    outputDataLength: outputTensor.data.length,
                    sampleOutputData: Array.from(outputTensor.data.slice(0, 10))
                };
                
                updateStatus('onnx-status', `‚úÖ ONNX inference successful in ${inferenceTime}ms`, 'success');
                updateResult('onnx-result', inferenceInfo);
                console.log('‚úÖ ONNX inference test passed:', inferenceInfo);
                
                // Cleanup
                inputTensor.dispose();
                Object.values(results).forEach(tensor => tensor.dispose());
                
            } catch (error) {
                updateStatus('onnx-status', `‚ùå ONNX inference failed: ${error.message}`, 'error');
                updateResult('onnx-result', error.stack);
                console.error('‚ùå ONNX inference test failed:', error);
            }
        }
        
        // Diagnostics
        async function runDiagnostics() {
            updateStatus('diagnostics-status', 'Running system diagnostics...', 'info');
            
            try {
                const diagnostics = {
                    timestamp: new Date().toISOString(),
                    browser: {
                        userAgent: navigator.userAgent,
                        language: navigator.language,
                        platform: navigator.platform,
                        hardwareConcurrency: navigator.hardwareConcurrency,
                        onLine: navigator.onLine
                    },
                    webgl: { supported: !!window.WebGLRenderingContext },
                    onnx: {
                        loaded: !!window.ort,
                        version: window.ort?.version || 'unknown'
                    },
                    tests: {
                        backend: null,
                        model: null
                    }
                };
                
                // Test WebGL
                try {
                    const canvas = document.createElement('canvas');
                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    if (gl) {
                        diagnostics.webgl.version = gl.getParameter(gl.VERSION);
                        diagnostics.webgl.vendor = gl.getParameter(gl.VENDOR);
                        diagnostics.webgl.renderer = gl.getParameter(gl.RENDERER);
                    }
                } catch (webglError) {
                    diagnostics.webgl.error = webglError.message;
                }
                
                // Test model file
                try {
                    const modelResponse = await fetch('./object_detecion_model/model_18_7.onnx', { method: 'HEAD' });
                    diagnostics.tests.model = {
                        accessible: modelResponse.ok,
                        size: modelResponse.headers.get('content-length'),
                        status: modelResponse.status
                    };
                } catch (modelError) {
                    diagnostics.tests.model = { error: modelError.message };
                }
                
                // Test backend
                try {
                    const backendResponse = await fetch('http://localhost:8000/health');
                    diagnostics.tests.backend = {
                        accessible: backendResponse.ok,
                        status: backendResponse.status,
                        data: backendResponse.ok ? await backendResponse.json() : null
                    };
                } catch (backendError) {
                    diagnostics.tests.backend = { error: backendError.message };
                }
                
                updateStatus('diagnostics-status', '‚úÖ Diagnostics completed', 'success');
                updateResult('diagnostics-result', diagnostics);
                console.log('‚úÖ Diagnostics completed:', diagnostics);
                
            } catch (error) {
                updateStatus('diagnostics-status', `‚ùå Diagnostics failed: ${error.message}`, 'error');
                updateResult('diagnostics-result', error.stack);
                console.error('‚ùå Diagnostics failed:', error);
            }
        }
        
        // Initialize
        console.log('üîß ONNX Inference Fix Test Page Loaded');
        console.log('üìã Available tests:');
        console.log('  - Backend Connection Test');
        console.log('  - Backend Inference Test');
        console.log('  - ONNX Model Loading Test');
        console.log('  - ONNX Inference Test');
        console.log('  - System Diagnostics');
    </script>
</body>
</html>