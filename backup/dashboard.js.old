/**
 * RoadGuardian Dashboard Application
 * Main module for the road hazard reporting dashboard
 * @module RoadGuardian
 */

const RoadGuardian = (function() {
  'use strict';

  // ===============================
  // Configuration
  // ===============================
  const CONFIG = {
    batch: {
      size: 50,
      blockSize: 80,
      viewportBuffer: 10,
      debounceTime: 250
    },
    map: {
      center: [32.0853, 34.7818], // Tel Aviv
      zoom: 13,
      maxZoom: 19,
      minZoom: 6,
      tileLayer: {
        url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
        attribution: '© OpenStreetMap contributors',
        backup: 'https://tile.openstreetmap.de/{z}/{x}/{y}.png'
      }
    },
    hazardTypes: {
      pothole: {
        icon: 'fa-circle-exclamation',
        color: '#dc3545',
        label: 'Pothole',
        description: 'Road surface damage'
      },
      speed_bump: {
        icon: 'fa-triangle-exclamation',
        color: '#ffc107',
        label: 'Speed Bump',
        description: 'Traffic calming measure'
      },
      manhole: {
        icon: 'fa-circle-dot',
        color: '#0dcaf0',
        label: 'Manhole',
        description: 'Manhole cover issue'
      },
      road_marking: {
        icon: 'fa-road',
        color: '#6c757d',
        label: 'Road Marking',
        description: 'Faded or missing road markings'
      },
      road_sign: {
        icon: 'fa-sign',
        color: '#198754',
        label: 'Road Sign',
        description: 'Missing or damaged road sign'
      },
      barrier: {
        icon: 'fa-bars',
        color: '#fd7e14',
        label: 'Barrier',
        description: 'Road barrier or obstruction'
      },
      other: {
        icon: 'fa-exclamation-circle',
        color: '#6c757d',
        label: 'Other',
        description: 'Other road hazard'
      }
    }
  };

  // API Routes
  const API_ROUTES = {
    reports: '/api/reports',
    status: '/api/reports/status', 
    stream: '/api/stream'
  };

  // ===============================
  // Module State
  // ===============================
  const state = {
    reportsById: new Map(),
    markersById: new Map(),
    rowsById: new Map(),
    map: null,
    clusterGroup: null,
    eventSource: null,
    loadingReports: false,
    seenReports: new Set(),
    filters: {
      type: [],
      date: null,
      status: 'all',
      search: ''
    },
    selection: { 
      activeId: null,
      lastUpdated: 0 
    },
    viewport: { 
      locked: false, 
      fitDone: false,
      bounds: null,
      zoom: null
    },
    stats: { 
      loadStartTime: 0,
      loadEndTime: 0,
      total: 0,
      new: 0,
      inProgress: 0,
      resolved: 0,
      lastSync: 0
    }
  };
  // ===============================
  // Private Functions
  // ===============================

  // Virtual Scroll Management
  function initVirtualScroll() {
    const container = document.querySelector('.virtual-table');
    if (!container) return;

    // Implementation details will be added later
    console.log('Virtual scroll initialized');
  }

  // Event Listeners Setup
  function initEventListeners() {
    // Filter change handler
    const typeFilter = document.getElementById('type-filter');
    if (typeFilter) {
      typeFilter.addEventListener('change', applyFilters);
    }

    // Additional event listeners will be added later
    console.log('Event listeners initialized');
  }

  // Map Initialization
  async function initMap() {
    try {
      // Create map instance with config settings
      state.map = L.map('map', {
        center: CONFIG.map.center,
        zoom: CONFIG.map.zoom,
        maxZoom: CONFIG.map.maxZoom,
        minZoom: CONFIG.map.minZoom
      });

      // Add tile layer
      L.tileLayer(CONFIG.map.tileLayer.url, {
        attribution: CONFIG.map.tileLayer.attribution
      }).addTo(state.map);

      // Initialize cluster group
      state.clusterGroup = L.markerClusterGroup().addTo(state.map);

      console.log('Map initialized successfully');
    } catch (error) {
      console.error('Failed to initialize map:', error);
      throw error;
    }
  }

  // Server-Sent Events Setup
  function initSSE() {
    try {
      state.eventSource = new EventSource('/api/stream');
      
      state.eventSource.onmessage = (event) => {
        const data = JSON.parse(event.data);
        // Handle incoming SSE data
        console.log('SSE data received:', data);
      };

      state.eventSource.onerror = (error) => {
        console.error('SSE connection error:', error);
      };

      console.log('SSE initialized successfully');
    } catch (error) {
      console.error('Failed to initialize SSE:', error);
      throw error;
    }
  }

  // UI Components Setup
  function initializeUI() {
    try {
      // Initialize UI components
      initVirtualScroll();
      
      // Additional UI setup will be added later
      console.log('UI initialized successfully');
    } catch (error) {
      console.error('Failed to initialize UI:', error);
      throw error;
    }
  }

  // ===============================
  // Public Functions
  // ===============================

  // Main Initialization
  async function init() {
    try {
      await Promise.all([
        initMap(),
        initEventListeners(),
        initSSE()
      ]);
      initializeUI();
      console.log('Dashboard initialized successfully');
    } catch (error) {
      console.error('Failed to initialize dashboard:', error);
      throw error;
    }
  }

  // Data Fetching
  async function getReports() {
    if (state.loadingReports) return;
    
    try {
      state.loadingReports = true;
      state.stats.loadStartTime = Date.now();
      
      // Implementation details will be added later
      console.warn('getReports: Not implemented yet');
      
    } catch (error) {
      console.error('Failed to get reports:', error);
      throw error;
    } finally {
      state.loadingReports = false;
      state.stats.loadEndTime = Date.now();
    }
  }

  // Report Status Management
  async function updateReportStatus(reportId, status) {
    try {
      // Implementation details will be added later
      console.warn('updateReportStatus: Not implemented yet');
    } catch (error) {
      console.error('Failed to update report status:', error);
      throw error;
    }
  }

  // Filter Application
  function applyFilters() {
    try {
      // Implementation details will be added later
      console.warn('applyFilters: Not implemented yet');
    } catch (error) {
      console.error('Failed to apply filters:', error);
      throw error;
    }
  }

  // Batch Loading
  async function loadNextBatch() {
    if (state.loadingReports) return;
    
    try {
      state.loadingReports = true;
      // Implementation details will be added later
      console.warn('loadNextBatch: Not implemented yet');
    } catch (error) {
      console.error('Failed to load next batch:', error);
      throw error;
    } finally {
      state.loadingReports = false;
    }
  }

  // ===============================
  // Module Initialization
  // ===============================

  // Helper Functions
function getHazardInfo(type) {
};

// Hazard icons and metadata configuration
const HAZARD_TYPES = {
  pothole: {
    icon: 'fa-circle-exclamation',
    color: '#dc3545',
    label: 'Pothole',
    description: 'Road surface damage'
  },
  speed_bump: {
    icon: 'fa-triangle-exclamation',
    color: '#ffc107',
    label: 'Speed Bump',
    description: 'Traffic calming measure'
  },
  manhole: {
    icon: 'fa-circle-dot',
    color: '#0dcaf0',
    label: 'Manhole',
    description: 'Manhole cover issue'
  },
  road_marking: {
    icon: 'fa-road',
    color: '#6c757d',
    label: 'Road Marking',
    description: 'Faded or missing road markings'
  },
  road_sign: {
    icon: 'fa-sign',
    color: '#198754',
    label: 'Road Sign',
    description: 'Missing or damaged road sign'
  },
  barrier: {
    icon: 'fa-bars',
    color: '#fd7e14',
    label: 'Barrier',
    description: 'Road barrier or obstruction'
  },
  other: {
    icon: 'fa-exclamation-circle',
    color: '#6c757d',
    label: 'Other',
    description: 'Other road hazard'
  }
};

// ===============================
// Utility Functions
// ===============================

// Get hazard type information with fallback
function getHazardInfo(type) {
  const hazardType = type?.toLowerCase() || 'other';
  return CONFIG.hazardTypes[hazardType] || CONFIG.hazardTypes.other;
}

// Get icon for hazard type
function getHazardIcon(type) {
  return getHazardInfo(type).icon;
}
function getHazardDescription(type) {
  return getHazardInfo(type).description;
}

// Map marker cluster group
// Module state variables
// API Routes
// Core dashboard functions

// Event listeners initialization
function initEventListeners() {
  // Filters
  document.getElementById('status-filter')?.addEventListener('change', onFiltersChanged);
  document.getElementById('type-filter')?.addEventListener('change', onFiltersChanged);
  document.getElementById('date-filter')?.addEventListener('change', onFiltersChanged);
  
  // Refresh button
  document.getElementById('refresh-btn')?.addEventListener('click', () => loadInitialData(true));
  
  // Image modal
  const imageModal = document.getElementById('imageModal');
  if (imageModal) {
    imageModal.addEventListener('show.bs.modal', (e) => {
      const button = e.relatedTarget;
      const imageUrl = button.dataset.imageUrl;
      document.getElementById('modal-image').src = imageUrl;
    });
  }
}

// Utility functions
function notify(message, type = 'info') {
  const toastContainer = document.getElementById('toast-container') || createToastContainer();
  const toast = document.createElement('div');
  toast.className = `toast toast-${type} show`;
  toast.innerHTML = `
    <div class="toast-header">
      <i class="fas fa-info-circle me-2"></i>
      <strong class="me-auto">${type.toUpperCase()}</strong>
      <button type="button" class="btn-close" data-bs-dismiss="toast"></button>
    </div>
    <div class="toast-body">${message}</div>
  `;
  toastContainer.appendChild(toast);
  setTimeout(() => toast.remove(), 5000);
}

function createToastContainer() {
  const container = document.createElement('div');
  container.id = 'toast-container';
  container.className = 'toast-container position-fixed bottom-0 end-0 p-3';
  document.body.appendChild(container);
  return container;
}

// Open image in a modal with zoom support
function openImageModal(imageUrl) {
  const modalHtml = `
    <div class="modal fade" id="imageModal" tabindex="-1">
      <div class="modal-dialog modal-lg modal-dialog-centered">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title">Report Image</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
          </div>
          <div class="modal-body text-center p-0">
            <div class="image-container">
              <img src="${imageUrl}" class="img-fluid" alt="Report image">
            </div>
          </div>
        </div>
      </div>
    </div>
  `;

  // Remove existing modal if any
  document.getElementById('imageModal')?.remove();
  
  // Add new modal to DOM
  document.body.insertAdjacentHTML('beforeend', modalHtml);
  
  // Initialize and show modal
  const modal = new bootstrap.Modal(document.getElementById('imageModal'));
  modal.show();
}

// Utility function for debouncing
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

async function fetchWithTimeout(url, options = {}) {
  const { timeout = 60000 } = options;
  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), timeout);
  const response = await fetch(url, { ...options, signal: controller.signal, credentials: 'include' });
  clearTimeout(id);
  return response;
}

// Debounce utility for map fitting with error handling and animations
let fitBoundsTimeoutId = null;
function debounceFitBounds(bounds, options = {}, delay = 100) {
  if (!bounds || !bounds.isValid()) return;
  
  clearTimeout(fitBoundsTimeoutId);
  fitBoundsTimeoutId = setTimeout(() => {
    try {
      // Save current state
      const currentZoom = store.map.getZoom();
      const currentCenter = store.map.getCenter();
      
      store.map.fitBounds(bounds, {
        ...options,
        animate: true,
        duration: 1,
        easeLinearity: 0.5,
        maxZoom: options.maxZoom || 15
      });
      
      // Update viewport state
      store.viewport.zoom = store.map.getZoom();
      store.viewport.bounds = bounds;
      
    } catch (error) {
      console.error('Error fitting bounds:', error);
      notify('Error updating map view', 'error');
    }
  }, delay);
}

// Map initialization
async function initMap() {
  try {
    // Create map instance
    store.map = L.map('map', {
      center: [32.0853, 34.7818], // Tel Aviv
      zoom: 13,
      zoomControl: true,
      maxZoom: 19,
      minZoom: 6
    });

    // Add tile layer with backup
    const mainTileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors',
      maxZoom: 19,
      crossOrigin: true
    });

    const backupTileLayer = L.tileLayer('https://tile.openstreetmap.de/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors',
      maxZoom: 19,
      crossOrigin: true
    });

    // Try to add the main tile layer, fall back to backup if it fails
    mainTileLayer.on('tileerror', function(e) {
      console.log('Main tile layer failed, switching to backup');
      store.map.removeLayer(mainTileLayer);
      backupTileLayer.addTo(store.map);
    });

    mainTileLayer.addTo(store.map);

    // Create marker cluster group
    store.clusterGroup = L.markerClusterGroup({
      chunkedLoading: true,
      spiderfyOnMaxZoom: true,
      showCoverageOnHover: false,
      zoomToBoundsOnClick: true,
      maxClusterRadius: 50
    }).addTo(store.map);

    // Enable responsive bounds updates
    store.map.on('moveend', () => {
      if (!store.viewport.locked) {
        updateVisibleReports();
      }
    });

    return store.map;
  } catch (error) {
    console.error('Error initializing map:', error);
    throw error;
  }
}

// SSE handling
function initSSE() {
  if (store.eventSource) {
    store.eventSource.close();
  }
  
  try {
    store.eventSource = new EventSource('/api/reports/stream');
    const pendingReports = new Set();
    let updateTimeout = null;
    let processingReports = false;
    
    store.eventSource.addEventListener('report:new', async (e) => {
      const report = JSON.parse(e.data);
      pendingReports.add(report);
      
      if (!updateTimeout && !processingReports) {
        updateTimeout = setTimeout(async () => {
          processingReports = true;
          const reportsToProcess = Array.from(pendingReports);
          pendingReports.clear();
          updateTimeout = null;
          
          try {
            await processPendingReports(reportsToProcess);
          } catch (error) {
            console.error('Error processing reports:', error);
            notify('Error processing new reports', 'error');
          } finally {
            processingReports = false;
            
            // If more reports accumulated during processing, schedule another update
            if (pendingReports.size > 0) {
              updateTimeout = setTimeout(() => {
                processPendingReports(Array.from(pendingReports));
                pendingReports.clear();
                updateTimeout = null;
              }, 250);
            }
          }
        }, 250); // debounce time
      }
    });
    
    store.eventSource.onerror = (error) => {
      console.error('SSE connection failed:', error);
      store.eventSource.close();
      notify('Lost connection to server. Retrying in 5s...', 'warning');
      setTimeout(initSSE, 5000);
    };

    store.eventSource.onopen = () => {
      console.log('SSE connection established');
      notify('Connected to real-time updates', 'success');
    };
  } catch (error) {
    console.error('Failed to initialize SSE:', error);
    showNotification('Failed to connect to real-time updates', 'error');
  }
}

// Process new reports from SSE
async function processPendingReports(reports) {
  const newMarkers = [];
  const geocodingPromises = [];
  
  // First pass: store reports and initiate geocoding
  for (const report of reports) {
    if (!store.reportsById.has(report.id)) {
      store.reportsById.set(report.id, report);
      if (!report.lat || !report.lng) {
        geocodingPromises.push(getReportCoordinates(report));
      }
    }
  }

  // Wait for geocoding to complete if needed
  if (geocodingPromises.length > 0) {
    await Promise.allSettled(geocodingPromises);
  }

  // Second pass: create markers and update UI
  requestAnimationFrame(() => {
    for (const report of reports) {
      if (!store.markersById.has(report.id) && report.lat && report.lng) {
        const marker = createReportMarker(report);
        store.markersById.set(report.id, marker);
        newMarkers.push(marker);
      }
    }
    
    if (newMarkers.length > 0) {
      store.clusterGroup.addLayers(newMarkers);
    }
    
    virtualScroll.updateTotal(store.reportsById.size);
    updateStats();
    
    if (reports.length > 0) {
      notify(`${reports.length} new reports received`, 'info');
    }
  });
}

// Data loading
async function loadInitialData(showLoader = true) {
  if (showLoader) {
    document.getElementById('map-loader').style.display = 'flex';
    document.getElementById('table-loader').style.display = 'flex';
  }
  
  store.stats.loadStartTime = performance.now();
  let firstBatch = true;
  
  try {
    // Health check with retries
    let healthRes;
    let retries = 3;
    
    while (retries > 0) {
      try {
        healthRes = await fetch('/api/health');
        if (healthRes.ok) break;
        
        const errorData = await healthRes.json();
        console.warn(`Health check attempt ${4-retries} failed:`, errorData);
        retries--;
        
        if (retries > 0) {
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      } catch (error) {
        console.warn(`Health check attempt ${4-retries} failed:`, error);
        retries--;
        if (retries > 0) {
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      }
    }
    
    if (!healthRes || !healthRes.ok) {
      throw new Error('Health check failed after multiple attempts');
    }
    
    let cursor = null;
    let hasMore = true;
    
    while (hasMore) {
      const url = new URL('/api/reports', window.location.origin);
      url.searchParams.set('limit', BATCH_SIZE.toString());
      if (cursor) url.searchParams.set('cursor', cursor);
      
      const res = await fetch(url);
      if (!res.ok) throw new Error('Failed to fetch reports');
      
      const data = await res.json();
      await processBatch(data.items, firstBatch);
      
      cursor = data.nextCursor;
      hasMore = cursor !== null;
      firstBatch = false;
    }
    
  } catch (error) {
    console.error('Error loading data:', error);
    notify('Failed to load reports', 'error');
  } finally {
    store.stats.loadEndTime = performance.now();
    updateLoadTime();
    
    if (showLoader) {
      document.getElementById('map-loader').style.display = 'none';
      document.getElementById('table-loader').style.display = 'none';
    }
  }
}

// Get report coordinates from server
async function getReportCoordinates(report) {
  if (report.lat && report.lng) {
    return { lat: report.lat, lng: report.lng };
  }

  if (!report.location) {
    console.warn('Report has no location data:', report.id);
    return null;
  }

  try {
    const response = await fetch(`/api/geocode?address=${encodeURIComponent(report.location)}`, {
      credentials: 'include'
    });

    if (!response.ok) {
      if (response.status === 404) {
        console.warn(`Location not found for report ${report.id}: ${report.location}`);
        return null;
      }
      throw new Error(`Geocoding failed with status: ${response.status}`);
    }

    const data = await response.json();
    if (data && data.lat && data.lng) {
      // Update the report in our store with the coordinates
      report.lat = data.lat;
      report.lng = data.lng;
      report.displayName = data.displayName;
      return { lat: data.lat, lng: data.lng };
    }
  } catch (error) {
    console.error('Error geocoding report location:', error);
    notify('Error getting location coordinates', 'warning');
  }

  return null;
}

// Process a batch of reports
async function processBatch(reports, isFirstBatch = false) {
  return new Promise(async (resolve) => {
    const newMarkers = [];
    const geocodingPromises = [];

    // First, store all reports and create geocoding promises
    for (const report of reports) {
      store.reportsById.set(report.id, report);
      if (!report.lat || !report.lng) {
        geocodingPromises.push(getReportCoordinates(report));
      }
    }

    // Wait for all geocoding to complete
    if (geocodingPromises.length > 0) {
      await Promise.allSettled(geocodingPromises);
    }

    // Now create markers for reports with coordinates
    requestAnimationFrame(() => {
      for (const report of reports) {
        if (report.lat && report.lng) {
          const marker = createReportMarker(report);
          store.markersById.set(report.id, marker);
          newMarkers.push(marker);
        }
      }

      if (newMarkers.length > 0) {
        store.clusterGroup.addLayers(newMarkers);

        if (isFirstBatch && !store.viewport.fitDone) {
          fitMapToMarkers();
          store.viewport.fitDone = true;
        }
      }

      virtualScroll.updateTotal(store.reportsById.size);
      updateStats();
      resolve();
    });
  });
}

// Create an interactive map marker with a custom icon and tooltip
function createReportMarker(report) {
  if (!report.lat || !report.lng) {
    console.warn('Attempted to create marker without coordinates:', report.id);
    return null;
  }

  const isNewReport = !seenReports.has(report.id);
  const reportType = report.type.toLowerCase();
  const statusClass = report.status.toLowerCase();

  // Generate marker HTML with animations and status indicators
  const markerHtml = `
    <div class="marker-content ${isNewReport ? 'new-marker' : ''} ${statusClass}-status">
      <div class="marker-icon ${reportType}">
        <i class="fas ${getHazardIcon(reportType)}"></i>
        ${isNewReport ? '<span class="pulse-ring"></span>' : ''}
      </div>
      ${report.severity ? `<span class="severity-indicator ${report.severity}"></span>` : ''}
    </div>
  `;

  // Create custom marker icon with proper sizing and anchor
  const markerIcon = L.divIcon({
    html: markerHtml,
    className: `custom-marker ${reportType}-marker`,
    iconSize: [40, 40],
    iconAnchor: [20, 40],
    tooltipAnchor: [0, -40]
  });

  // Create marker with custom options and interactivity
  const marker = L.marker([report.lat, report.lng], { 
    icon: markerIcon,
    riseOnHover: true,
    title: report.title || report.location
  });
  
  // Create enhanced popup content
  const popupContent = `
    <div class="report-popup ${report.type.toLowerCase()}-popup">
      <div class="popup-header">
        <h6 class="report-type ${report.type.toLowerCase()}">
          <i class="fas ${getHazardIcon(report.type)} me-2"></i>
          ${report.type}
        </h6>
        <span class="badge status-${report.status.toLowerCase()}">${report.status}</span>
      </div>
      
      <div class="popup-body">
        <div class="location-info">
          <p class="report-location">
            <i class="fas fa-map-marker-alt me-2"></i>
            ${report.displayName || report.location}
          </p>
          <p class="report-time">
            <i class="far fa-clock me-2"></i>
            ${formatDate(report.time)}
          </p>
        </div>
        
        ${report.description ? `
          <div class="report-description">
            <p>${report.description}</p>
          </div>
        ` : ''}
        
        ${report.image ? `
          <div class="report-media">
            <img src="${report.image}" 
                 alt="Report image" 
                 class="report-image"
                 loading="lazy"
                 onclick="openImageModal('${report.image}')" />
          </div>
        ` : ''}
        
        ${report.severity ? `
          <div class="severity-indicator ${report.severity.toLowerCase()}">
            <i class="fas fa-exclamation-triangle me-2"></i>
            ${report.severity} severity
          </div>
        ` : ''}
      </div>
      
      <div class="popup-footer">
        <button onclick="focusReport('${report.id}')" class="btn btn-sm btn-primary">
          <i class="fas fa-info-circle me-1"></i> Details
        </button>
        ${report.status === 'new' ? `
          <button onclick="updateReportStatus('${report.id}', 'in-progress')" class="btn btn-sm btn-warning">
            <i class="fas fa-tasks me-1"></i> Start
          </button>
        ` : ''}
      </div>
    </div>
  `;
  
  // Bind popup with enhanced options
  marker.bindPopup(popupContent, {
    inlineSize: '350px',
    className: `custom-popup ${report.type.toLowerCase()}-popup`,
    autoPan: true,
    closeButton: true,
    closeOnClick: false,
    autoClose: false
  });
  
  marker.on('click', () => {
    if (store.selection.activeId !== report.id) {
      store.selection.activeId = report.id;
      window.RoadGuardian.focusReport(report.id);
    }
  });
  
  marker.on('popupopen', () => {
    if (isNewReport) {
      seenReports.add(report.id);
      const element = marker.getElement();
      if (element) {
        element.classList.remove('new-marker');
      }
    }
  });

  return marker;
}

// Format a date relative to now (e.g. "2 hours ago")
function formatDate(dateString) {
  if (!dateString) {
    return 'N/A';
  }
  
  try {
    const date = new Date(dateString);
    if (isNaN(date.getTime())) {
      return 'Invalid date';
    }
    
    const now = new Date();
    const diff = now - date;
    
    if (diff < 24 * 60 * 60 * 1000) {
      const rtf = new Intl.RelativeTimeFormat('he', { numeric: 'auto' });
      const hours = Math.floor(diff / (60 * 60 * 1000));
      
      if (hours === 0) {
        const minutes = Math.floor(diff / (60 * 1000));
        return rtf.format(-minutes, 'minute');
      }
      
      return rtf.format(-hours, 'hour');
    }
    
    return date.toLocaleString('he-IL', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
    
  } catch (error) {
    console.error('Error formatting date:', error);
    return 'Invalid date';
  }
} {
  if (loadingReports) return;
  loadingReports = true;

  try {
    if (showSpinner) {
      const refreshBtn = document.getElementById('refresh-btn');
      const spinner = addLoadingSpinner(refreshBtn);
      refreshBtn.disabled = true;
    }

    const res = await fetchWithTimeout('/api/reports');
    if (!res.ok) throw new Error(`Server error: ${res.statusText}`);
    
    const newReports = await res.json();
    
    // Compare with existing reports to identify updates
    const existingIds = new Set(allReports.map(r => r.id));
    const updatedReports = newReports.filter(r => !existingIds.has(r.id));
    
    allReports = newReports;
    
    // Only fit map bounds if there are new reports
    await applyFilters(updatedReports.length > 0);
    
    if (updatedReports.length > 0) {
      notify(`${updatedReports.length} new reports loaded`, 'success');
    }

  } catch (error) {
    console.error('[ERROR] Failed to load reports:', error);
    notify('Could not load reports.', 'error');
  } finally {
    loadingReports = false;
    const refreshBtn = document.getElementById('refresh-btn');
    refreshBtn.disabled = false;
    const spinner = refreshBtn.querySelector('.spinner-border');
    if (spinner) spinner.remove();
  }
}

// Auto-refresh functionality
let autoRefreshInterval;

function startAutoRefresh(intervalMs = 30000) {
  if (autoRefreshInterval) clearInterval(autoRefreshInterval);
  autoRefreshInterval = setInterval(() => loadAndRender(false), intervalMs);
}

function stopAutoRefresh() {
  if (autoRefreshInterval) {
    clearInterval(autoRefreshInterval);
    autoRefreshInterval = null;
  }
}

function applyFilters() {
  try {
    const typeFilter = document.getElementById('type-filter')?.value || '';
    console.log('Applying filters, type filter:', typeFilter);
    
    filteredReports = allReports.filter(report => {
      if (!typeFilter) return true;
      const reportType = (report.type || '').toLowerCase();
      return typeFilter.split(',').includes(reportType);
    });
    
    console.log('Filtered reports:', filteredReports.length);
    plotReportsOnMap(filteredReports);
  } catch (error) {
    console.error('Error applying filters:', error);
    notify('Error applying filters', 'error');
  }
}

// Make sure initMap is globally available
window.initMap = initMap;

// --- EVENT LISTENERS ---
function initializeUI() {
  console.log('Initializing UI components...');
  
  const legendFilters = document.getElementById('legend-filters');
  if (legendFilters) {
    legendFilters.addEventListener('click', (e) => {
      if (e.target.classList.contains('legend-chip')) {
        e.target.classList.toggle('active');
        const activeChips = legendFilters.querySelectorAll('.legend-chip.active');
        const selectedTypes = Array.from(activeChips).map(chip => chip.dataset.type);
        const typeFilterDropdown = document.getElementById('type-filter');
        if (typeFilterDropdown) {
          typeFilterDropdown.value = selectedTypes.join(',');
          typeFilterDropdown.dispatchEvent(new Event('change'));
        }
      }
    });
  }

  // Define main initialization function
  // Define core functions
  async function getReports() {
    // Implementation will be added later
    console.warn('getReports: Not implemented yet');
  }

  async function updateReportStatus(reportId, status) {
    // Implementation will be added later
    console.warn('updateReportStatus: Not implemented yet');
  }

  async function loadNextBatch() {
    // Implementation will be added later
    console.warn('loadNextBatch: Not implemented yet');
  }

  async function init() {
    try {
      await Promise.all([
        initMap(),
        initEventListeners(),
        initSSE()
      ]);
      initializeUI();
    } catch (error) {
      console.error('Failed to initialize dashboard:', error);
    }
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init().catch(error => {
      console.error('Failed to initialize on load:', error);
    });
  }

  return publicAPI;
})();

// Export for browser globals
window.RoadGuardian = RoadGuardian;