<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ONNX Model Test</title>
</head>
<body>
    <h1>ONNX Model Loading Test</h1>
    <div id="status">Loading...</div>
    <div id="results"></div>
    
    <script src="./ort/ort.wasm.min.js"></script>
    <script>
        async function testModelLoading() {
            const statusDiv = document.getElementById('status');
            const resultsDiv = document.getElementById('results');
            
            try {
                statusDiv.innerHTML = "Configuring ONNX Runtime...";
                
                // Configure ONNX Runtime environment for ES module compatibility
                ort.env.wasm.wasmPaths = 'ort/';  // Remove leading dot and slash
                ort.env.wasm.numThreads = 1; // Use single thread to avoid ES module issues
                ort.env.wasm.simd = true;
                ort.env.wasm.proxy = false;
                ort.env.wasm.useWebWorkers = false; // Disable dynamic imports
                
                statusDiv.innerHTML = "Testing model paths...";
                
                // Test model paths (both static and direct routes)
                const modelPaths = [
                    './object_detecion_model/model 18_7.onnx',
                    './object_detecion_model/road_damage_detection_last_version.onnx',
                    './object_detecion_model/last_model_train12052025.onnx',
                    './object_detecion_model/road_damage_detection_simplified.onnx',
                    // Direct server routes as fallback
                    '/object_detecion_model/model 18_7.onnx',
                    '/object_detecion_model/road_damage_detection_last_version.onnx',
                    '/object_detecion_model/last_model_train12052025.onnx',
                    '/object_detecion_model/road_damage_detection_simplified.onnx'
                ];
                
                let results = [];
                for (const path of modelPaths) {
                    try {
                        // URL encode the path to handle spaces in filenames
                        const encodedPath = encodeURI(path);
                        const response = await fetch(encodedPath, { method: 'HEAD' });
                        results.push({
                            path: path,
                            encodedPath: encodedPath,
                            status: response.ok ? 'Found' : 'Not Found',
                            size: response.headers.get('content-length') || 'Unknown'
                        });
                    } catch (e) {
                        results.push({
                            path: path,
                            encodedPath: 'N/A',
                            status: 'Error: ' + e.message,
                            size: 'N/A'
                        });
                    }
                }
                
                statusDiv.innerHTML = "Model file check complete";
                
                // Display results
                let html = '<h2>Model File Status:</h2><table border="1"><tr><th>Path</th><th>Status</th><th>Size (bytes)</th></tr>';
                results.forEach(result => {
                    html += `<tr><td>${result.path}</td><td>${result.status}</td><td>${result.size}</td></tr>`;
                });
                html += '</table>';
                
                // Try to load the first available model
                const availableModel = results.find(r => r.status === 'Found');
                if (availableModel) {
                    statusDiv.innerHTML = `Attempting to load: ${availableModel.path}`;
                    
                    const executionProviders = [];
                    
                    // Check WebGL support
                    if (ort.env.webgl?.isSupported) {
                        executionProviders.push('webgl');
                        html += '<p>✅ WebGL execution provider available</p>';
                    }
                    
                    // Always add WASM as fallback
                    executionProviders.push('wasm');
                    html += '<p>✅ WASM execution provider available</p>';
                    
                    const session = await ort.InferenceSession.create(
                        availableModel.encodedPath || availableModel.path,
                        { 
                            executionProviders: executionProviders,
                            graphOptimizationLevel: 'all',
                            enableCpuMemArena: true,
                            logSeverityLevel: 0
                        }
                    );
                    
                    html += `<h2>✅ MODEL LOADED SUCCESSFULLY!</h2>`;
                    html += `<p><strong>Model:</strong> ${availableModel.path}</p>`;
                    html += `<p><strong>Input Names:</strong> ${session.inputNames.join(', ')}</p>`;
                    html += `<p><strong>Output Names:</strong> ${session.outputNames.join(', ')}</p>`;
                    html += `<p><strong>Execution Providers:</strong> ${executionProviders.join(', ')}</p>`;
                    
                    statusDiv.innerHTML = "✅ Model loaded successfully!";
                    statusDiv.style.color = "green";
                    
                } else {
                    html += '<h2>❌ No models found</h2>';
                    statusDiv.innerHTML = "❌ No models available";
                    statusDiv.style.color = "red";
                }
                
                resultsDiv.innerHTML = html;
                
            } catch (error) {
                statusDiv.innerHTML = `❌ Error: ${error.message}`;
                statusDiv.style.color = "red";
                resultsDiv.innerHTML = `<h2>Error Details:</h2><pre>${error.stack || error.message}</pre>`;
                console.error('Model loading test failed:', error);
            }
        }
        
        // Run test when page loads
        window.addEventListener('load', testModelLoading);
    </script>
</body>
</html>