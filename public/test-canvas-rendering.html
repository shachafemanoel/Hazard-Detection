<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Rendering Performance Test</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: system-ui, -apple-system, sans-serif;
            background: #0a0e1a;
            color: white;
        }
        
        .test-container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .video-container {
            position: relative;
            width: 100%;
            height: 400px;
            background: #000;
            margin-bottom: 20px;
            border-radius: 8px;
            overflow: hidden;
        }
        
        #test-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        #test-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .test-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .test-button {
            padding: 10px 20px;
            background: #00e5ff;
            color: #000;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
        }
        
        .test-button:hover {
            background: #00bcd4;
        }
        
        .test-results {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .metric {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .metric:last-child {
            border-bottom: none;
        }
        
        .metric-value {
            font-weight: bold;
            color: #00e5ff;
        }
        
        .status-good { color: #4caf50; }
        .status-warning { color: #ff9800; }
        .status-error { color: #f44336; }
        
        .test-detections {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .detection-test {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .detection-test h3 {
            margin: 0 0 10px 0;
            color: #00e5ff;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>🎯 Canvas Rendering Performance Test</h1>
        <p>This test validates the canvas rendering pipeline fixes for accurate detection overlays.</p>
        
        <div class="video-container">
            <video id="test-video" autoplay playsinline muted></video>
            <canvas id="test-canvas"></canvas>
        </div>
        
        <div class="test-controls">
            <button class="test-button" onclick="startCamera()">Start Camera</button>
            <button class="test-button" onclick="runAccuracyTest()">Test Accuracy</button>
            <button class="test-button" onclick="runPerformanceTest()">Test Performance</button>
            <button class="test-button" onclick="testDifferentDPR()">Test DPR Scaling</button>
            <button class="test-button" onclick="testMobileOrientation()">Test Orientation</button>
            <button class="test-button" onclick="clearTests()">Clear</button>
        </div>
        
        <div class="test-results" id="results">
            <h2>Test Results</h2>
            <div class="metric">
                <span>Status:</span>
                <span class="metric-value" id="test-status">Ready to test</span>
            </div>
        </div>
        
        <div class="test-detections" id="test-grid">
            <!-- Test scenarios will be populated here -->
        </div>
    </div>

    <script type="module">
        import { 
            getVideoDisplayRect, 
            mapModelToCanvas, 
            validateMappingAccuracy,
            debugDrawMapping 
        } from './js/utils/coordsMap.js';

        let video, canvas, ctx;
        let testResults = {};
        let animationFrameId;

        // Initialize test environment
        document.addEventListener('DOMContentLoaded', () => {
            video = document.getElementById('test-video');
            canvas = document.getElementById('test-canvas');
            ctx = canvas.getContext('2d');
            
            console.log('🔧 Canvas rendering test initialized');
            setupCanvas();
        });

        function setupCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            
            console.log(`📐 Test canvas setup: ${canvas.width}x${canvas.height} (${dpr}x DPR)`);
        }

        window.startCamera = async function() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: { ideal: 1280 }, height: { ideal: 720 } }
                });
                video.srcObject = stream;
                
                video.onloadedmetadata = () => {
                    setupCanvas();
                    updateStatus('Camera started', 'good');
                    console.log('📹 Test camera started:', video.videoWidth, 'x', video.videoHeight);
                };
            } catch (err) {
                updateStatus('Camera access failed: ' + err.message, 'error');
            }
        };

        window.runAccuracyTest = function() {
            if (!video.videoWidth) {
                updateStatus('Start camera first', 'warning');
                return;
            }

            updateStatus('Running accuracy tests...', 'warning');
            
            const testCases = [
                { name: 'Center Detection', x1: 0.4, y1: 0.4, x2: 0.6, y2: 0.6, expected_accuracy: 1 },
                { name: 'Top-Left Corner', x1: 0.0, y1: 0.0, x2: 0.2, y2: 0.2, expected_accuracy: 1 },
                { name: 'Bottom-Right Corner', x1: 0.8, y1: 0.8, x2: 1.0, y2: 1.0, expected_accuracy: 1 },
                { name: 'Edge Case - Narrow', x1: 0.45, y1: 0.1, x2: 0.55, y2: 0.9, expected_accuracy: 1 },
                { name: 'Edge Case - Wide', x1: 0.1, y1: 0.45, x2: 0.9, y2: 0.55, expected_accuracy: 1 }
            ];

            const modelInputSize = 640;
            const dpr = window.devicePixelRatio || 1;
            const videoDisplayRect = getVideoDisplayRect(video);
            
            let passedTests = 0;
            let totalTests = testCases.length;
            
            ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);
            
            testCases.forEach((testCase, index) => {
                // Convert normalized coordinates to model coordinates
                const detection = {
                    x1: testCase.x1 * modelInputSize,
                    y1: testCase.y1 * modelInputSize,
                    x2: testCase.x2 * modelInputSize,
                    y2: testCase.y2 * modelInputSize
                };

                // Map to canvas coordinates
                const mappedCoords = mapModelToCanvas(
                    detection,
                    modelInputSize,
                    { width: canvas.width, height: canvas.height },
                    videoDisplayRect,
                    dpr
                );

                // Validate accuracy
                const mapping = {
                    displayWidth: videoDisplayRect.width,
                    displayHeight: videoDisplayRect.height,
                    offsetX: videoDisplayRect.x,
                    offsetY: videoDisplayRect.y,
                    dpr: dpr
                };

                const isAccurate = validateMappingAccuracy(
                    testCase, // original normalized coordinates
                    mappedCoords,
                    { x: 1, y: 1 }, // ±1px tolerance as required
                    mapping
                );

                if (isAccurate) {
                    passedTests++;
                }

                // Draw test detection
                const color = isAccurate ? '#4caf50' : '#f44336';
                debugDrawMapping(canvas, 
                    { class: testCase.name, confidence: 0.9 },
                    {
                        x1: mappedCoords.x1 / dpr,
                        y1: mappedCoords.y1 / dpr,
                        x2: mappedCoords.x2 / dpr,
                        y2: mappedCoords.y2 / dpr
                    },
                    color,
                    { showCenter: true, showCoords: true, dpr: dpr }
                );

                console.log(`🎯 Test "${testCase.name}": ${isAccurate ? 'PASS' : 'FAIL'}`, {
                    original: testCase,
                    mapped: mappedCoords,
                    videoDisplayRect,
                    dpr
                });
            });

            const accuracy = (passedTests / totalTests * 100).toFixed(1);
            const status = passedTests === totalTests ? 'good' : 
                          passedTests > totalTests * 0.8 ? 'warning' : 'error';
            
            updateStatus(`Accuracy Test: ${passedTests}/${totalTests} passed (${accuracy}%)`, status);
            
            testResults.accuracy = {
                passed: passedTests,
                total: totalTests,
                percentage: accuracy
            };
        };

        window.runPerformanceTest = function() {
            if (!video.videoWidth) {
                updateStatus('Start camera first', 'warning');
                return;
            }

            updateStatus('Running performance tests...', 'warning');
            
            const startTime = performance.now();
            let frameCount = 0;
            let totalRenderTime = 0;
            const testDuration = 5000; // 5 seconds
            
            const mockDetections = Array.from({ length: 10 }, (_, i) => ({
                x1: Math.random() * 300,
                y1: Math.random() * 300,
                x2: Math.random() * 300 + 300,
                y2: Math.random() * 300 + 300,
                confidence: 0.5 + Math.random() * 0.5,
                classId: Math.floor(Math.random() * 4)
            }));

            function performanceTestLoop() {
                const frameStart = performance.now();
                
                // Clear canvas
                const dpr = window.devicePixelRatio || 1;
                ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);
                
                // Render test detections
                const videoDisplayRect = getVideoDisplayRect(video);
                mockDetections.forEach((detection, index) => {
                    const mappedBox = mapModelToCanvas(
                        detection,
                        640,
                        { width: canvas.width, height: canvas.height },
                        videoDisplayRect,
                        dpr
                    );

                    // Simulate full bounding box drawing
                    ctx.strokeStyle = '#00e5ff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(
                        mappedBox.x1 / dpr,
                        mappedBox.y1 / dpr,
                        (mappedBox.x2 - mappedBox.x1) / dpr,
                        (mappedBox.y2 - mappedBox.y1) / dpr
                    );
                });
                
                const frameEnd = performance.now();
                totalRenderTime += (frameEnd - frameStart);
                frameCount++;
                
                if (performance.now() - startTime < testDuration) {
                    animationFrameId = requestAnimationFrame(performanceTestLoop);
                } else {
                    // Calculate results
                    const avgFPS = (frameCount / (testDuration / 1000)).toFixed(1);
                    const avgRenderTime = (totalRenderTime / frameCount).toFixed(2);
                    
                    const fpsStatus = avgFPS >= 15 ? 'good' : avgFPS >= 10 ? 'warning' : 'error';
                    updateStatus(`Performance: ${avgFPS} FPS, ${avgRenderTime}ms avg render`, fpsStatus);
                    
                    testResults.performance = {
                        fps: avgFPS,
                        avgRenderTime: avgRenderTime,
                        frameCount: frameCount
                    };
                    
                    console.log('🚀 Performance test complete:', testResults.performance);
                }
            }
            
            performanceTestLoop();
        };

        window.testDifferentDPR = function() {
            const testDPRValues = [1.0, 1.25, 1.5, 2.0, 2.5];
            let results = [];
            
            testDPRValues.forEach(testDPR => {
                // Simulate different DPR values
                const originalDPR = window.devicePixelRatio;
                Object.defineProperty(window, 'devicePixelRatio', {
                    value: testDPR,
                    configurable: true
                });
                
                const videoDisplayRect = getVideoDisplayRect(video);
                const testDetection = {
                    x1: 320, y1: 240, x2: 420, y2: 340
                };
                
                const mappedCoords = mapModelToCanvas(
                    testDetection,
                    640,
                    { width: canvas.width, height: canvas.height },
                    videoDisplayRect,
                    testDPR
                );
                
                const isAccurate = validateMappingAccuracy(
                    { x1: 0.5, y1: 0.375, x2: 0.656, y2: 0.531 },
                    mappedCoords,
                    { x: 1, y: 1 },
                    {
                        displayWidth: videoDisplayRect.width,
                        displayHeight: videoDisplayRect.height,
                        offsetX: videoDisplayRect.x,
                        offsetY: videoDisplayRect.y,
                        dpr: testDPR
                    }
                );
                
                results.push({ dpr: testDPR, accurate: isAccurate });
                
                // Restore original DPR
                Object.defineProperty(window, 'devicePixelRatio', {
                    value: originalDPR,
                    configurable: true
                });
            });
            
            const passedDPR = results.filter(r => r.accurate).length;
            const status = passedDPR === results.length ? 'good' : 'warning';
            
            updateStatus(`DPR Test: ${passedDPR}/${results.length} DPR values passed`, status);
            
            testResults.dpr = results;
            console.log('📱 DPR test results:', results);
        };

        window.testMobileOrientation = function() {
            updateStatus('Testing orientation changes...', 'warning');
            
            // Simulate portrait orientation
            const originalWidth = canvas.clientWidth;
            const originalHeight = canvas.clientHeight;
            
            // Test portrait mode (taller than wide)
            canvas.style.width = '300px';
            canvas.style.height = '500px';
            setupCanvas();
            
            const portraitResult = runQuickAccuracyTest();
            
            // Test landscape mode (wider than tall)
            canvas.style.width = '600px';
            canvas.style.height = '300px';
            setupCanvas();
            
            const landscapeResult = runQuickAccuracyTest();
            
            // Restore original size
            canvas.style.width = originalWidth + 'px';
            canvas.style.height = originalHeight + 'px';
            setupCanvas();
            
            const bothPass = portraitResult && landscapeResult;
            const status = bothPass ? 'good' : 'warning';
            
            updateStatus(`Orientation: Portrait ${portraitResult ? 'PASS' : 'FAIL'}, Landscape ${landscapeResult ? 'PASS' : 'FAIL'}`, status);
            
            testResults.orientation = {
                portrait: portraitResult,
                landscape: landscapeResult
            };
        };

        function runQuickAccuracyTest() {
            if (!video.videoWidth) return false;
            
            const detection = { x1: 200, y1: 200, x2: 400, y2: 400 };
            const videoDisplayRect = getVideoDisplayRect(video);
            const dpr = window.devicePixelRatio || 1;
            
            const mappedCoords = mapModelToCanvas(
                detection,
                640,
                { width: canvas.width, height: canvas.height },
                videoDisplayRect,
                dpr
            );
            
            return validateMappingAccuracy(
                { x1: 0.3125, y1: 0.3125, x2: 0.625, y2: 0.625 },
                mappedCoords,
                { x: 1, y: 1 },
                {
                    displayWidth: videoDisplayRect.width,
                    displayHeight: videoDisplayRect.height,
                    offsetX: videoDisplayRect.x,
                    offsetY: videoDisplayRect.y,
                    dpr: dpr
                }
            );
        }

        window.clearTests = function() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            
            const dpr = window.devicePixelRatio || 1;
            ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);
            updateStatus('Tests cleared', 'good');
            testResults = {};
        };

        function updateStatus(message, status) {
            const statusEl = document.getElementById('test-status');
            statusEl.textContent = message;
            statusEl.className = 'metric-value status-' + status;
        }

        // Handle resize events
        window.addEventListener('resize', () => {
            setTimeout(setupCanvas, 100);
        });

        console.log('🎯 Canvas rendering test suite loaded');
    </script>
</body>
</html>