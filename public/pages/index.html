<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="/assets/icon.png" type="image/png">
  <title>Hazard Detection - Home</title>

  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/styles/theme.css" />
  <link rel="stylesheet" href="/styles/layout.css" />
  <link rel="stylesheet" href="/styles/components.css" />
  <link rel="stylesheet" href="/styles/unified-design.css" />
  
  <style>
    /* Page-specific styles */
    .hero-section {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #0f172a 100%);
      overflow: hidden;
    }
    
    .hero-bg-animation {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at 20% 80%, rgba(247, 200, 115, 0.1) 0%, transparent 50%),
                  radial-gradient(circle at 80% 20%, rgba(139, 92, 246, 0.1) 0%, transparent 50%),
                  radial-gradient(circle at 40% 40%, rgba(59, 130, 246, 0.05) 0%, transparent 50%);
      animation: backgroundPulse 8s ease-in-out infinite;
    }
    
    @keyframes backgroundPulse {
      0%, 100% { opacity: 0.5; transform: scale(1); }
      50% { opacity: 0.8; transform: scale(1.05); }
    }
    
    .hero-content {
      text-align: center;
      z-index: 10;
      max-width: 800px;
      padding: var(--space-3xl);
    }
    
    .hero-logo {
      width: 120px;
      height: 120px;
      margin: 0 auto var(--space-3xl);
      filter: drop-shadow(0 8px 24px rgba(247, 200, 115, 0.3));
      animation: logoFloat 6s ease-in-out infinite;
    }
    
    @keyframes logoFloat {
      0%, 100% { transform: translateY(0px); }
      50% { transform: translateY(-10px); }
    }
    
    .hero-title {
      font-size: clamp(2.5rem, 5vw, 4rem);
      font-weight: 700;
      margin-bottom: var(--space-lg);
      background: linear-gradient(135deg, var(--primary-accent), #fbbf24);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }
    
    .hero-subtitle {
      font-size: var(--font-size-xl);
      color: var(--text-secondary);
      margin-bottom: var(--space-3xl);
      line-height: 1.6;
    }
    
    .hero-actions {
      display: flex;
      flex-direction: column;
      gap: var(--space-lg);
      align-items: center;
    }
    
    .action-group {
      display: flex;
      gap: var(--space-lg);
      flex-wrap: wrap;
      justify-content: center;
    }
    
    .feature-grid {
      padding: var(--space-3xl) 0;
    }
    
    .feature-card {
      text-align: center;
      padding: var(--space-3xl);
      height: 100%;
    }
    
    .feature-icon {
      width: 80px;
      height: 80px;
      margin: 0 auto var(--space-2xl);
      background: linear-gradient(135deg, var(--primary-accent), #fbbf24);
      border-radius: var(--radius-xl);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
      color: #1e293b;
      box-shadow: 0 8px 24px rgba(247, 200, 115, 0.3);
    }
    
    .feature-title {
      font-size: var(--font-size-xl);
      font-weight: 600;
      margin-bottom: var(--space-md);
      color: var(--text-primary);
    }
    
    .feature-description {
      color: var(--text-secondary);
      line-height: 1.6;
    }
    
    .stats-section {
      padding: var(--space-3xl) 0;
      background: linear-gradient(135deg, rgba(247, 200, 115, 0.05), rgba(139, 92, 246, 0.05));
    }
    
    .stat-item {
      text-align: center;
      padding: var(--space-2xl);
    }
    
    .stat-number {
      font-size: var(--font-size-4xl);
      font-weight: 700;
      color: var(--primary-accent);
      margin-bottom: var(--space-sm);
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }
    
    .stat-label {
      color: var(--text-secondary);
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-size: var(--font-size-sm);
    }
    
    .cta-section {
      padding: var(--space-3xl) 0;
      text-align: center;
    }
    
    .upload-demo {
      max-width: 600px;
      margin: var(--space-3xl) auto 0;
    }
    
    .upload-area {
      padding: var(--space-3xl);
      border: 2px dashed rgba(255, 255, 255, 0.2);
      border-radius: var(--radius-xl);
      background: rgba(255, 255, 255, 0.02);
      transition: var(--transition-base);
      cursor: pointer;
    }
    
    .upload-area:hover {
      border-color: rgba(var(--primary-accent-rgb), 0.5);
      background: rgba(var(--primary-accent-rgb), 0.05);
    }
    
    .upload-area.dragover {
      border-color: var(--primary-accent);
      background: rgba(var(--primary-accent-rgb), 0.1);
      transform: scale(1.02);
    }
    
    .upload-icon {
      font-size: 3rem;
      color: var(--primary-accent);
      margin-bottom: var(--space-lg);
    }
    
    #demo-canvas {
      max-width: 100%;
      border: 2px solid var(--primary-accent);
      border-radius: var(--radius-lg);
      margin: var(--space-lg) 0;
    }
    
    .form-range {
      width: 100%;
      margin-top: var(--space-sm);
    }
    
    /* Page Layout */
    body {
      padding-top: 100px;
    }
    
    @media (max-width: 768px) {
      body {
        padding-top: 0;
        padding-bottom: 100px;
      }
      
      .hero-content {
        padding: var(--space-2xl);
      }
      
      .action-group {
        flex-direction: column;
        width: 100%;
      }
      
      .hero-logo {
        width: 80px;
        height: 80px;
      }
    }
    
    @media (max-width: 480px) {
      body {
        padding-top: 70px;
      }
      
      .feature-card {
        padding: var(--space-2xl);
      }
      
      .feature-icon {
        width: 60px;
        height: 60px;
        font-size: 1.5rem;
      }
    }
  </style>
</head>
<body>
  <!-- Unified Navigation Container -->
  <div id="unified-navigation-container"></div>

  <!-- Hero Section -->
  <section class="hero-section">
    <div class="hero-bg-animation"></div>
    <div class="hero-content">
      <img src="/assets/icon.png" alt="Hazard Detection Logo" class="hero-logo">
      <h1 class="hero-title">RoadGuardian</h1>
      <p class="hero-subtitle">AI-Powered Road Hazard Detection System</p>
      
      <div class="hero-actions">
        <div class="action-group">
          <a href="/pages/camera.html" class="btn btn-primary btn-lg">
            <i class="fas fa-camera"></i> Start Detection
          </a>
          <a href="/pages/dashboard.html" class="btn btn-glass btn-lg">
            <i class="fas fa-chart-line"></i> View Dashboard
          </a>
        </div>
        
        <div class="upload-demo">
          <div class="upload-area" id="upload-area">
            <div class="upload-icon">
              <i class="fas fa-cloud-upload-alt"></i>
            </div>
            <h3>Upload Image for Real Detection</h3>
            <p>Drag & drop an image or click to select</p>
            <input type="file" id="demo-upload" accept="image/*" style="display: none;">
            <button class="btn btn-primary" id="demo-upload-btn">
              <i class="fas fa-upload"></i> Upload Image
            </button>
          </div>
          
          <div id="demo-results" style="display: none;">
            <h4>AI Detection Results:</h4>
            <canvas id="demo-canvas"></canvas>
            <div class="mt-3">
              <label for="demo-confidence-slider">Confidence Threshold: <span id="demo-conf-value">0.5</span></label>
              <input type="range" id="demo-confidence-slider" class="form-range" min="0.1" max="1" step="0.1" value="0.5">
            </div>
            <div class="mt-3" id="save-report-section" style="display: none;">
              <button class="btn btn-success" id="save-report-btn">
                <i class="fas fa-save"></i> Save as Report
              </button>
              <p class="text-muted mt-2">
                <i class="fas fa-info-circle"></i> 
                Hazards detected! You can save this as an official report.
              </p>
            </div>
          </div>
          
          <!-- Loading indicator -->
          <div id="model-loading" style="display: none;" class="text-center mt-3">
            <div class="spinner-border text-primary" role="status">
              <span class="visually-hidden">Loading...</span>
            </div>
            <p class="mt-2">Loading AI model...</p>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- Features Section -->
  <section class="feature-grid">
    <div class="container">
      <div class="row g-4">
        <div class="col-md-4">
          <div class="feature-card glass-card">
            <div class="feature-icon">
              <i class="fas fa-eye"></i>
            </div>
            <h3 class="feature-title">Real-time Detection</h3>
            <p class="feature-description">Advanced AI models detect road hazards in real-time using your camera</p>
          </div>
        </div>
        
        <div class="col-md-4">
          <div class="feature-card glass-card">
            <div class="feature-icon">
              <i class="fas fa-map-marker-alt"></i>
            </div>
            <h3 class="feature-title">GPS Location</h3>
            <p class="feature-description">Automatically captures GPS coordinates for precise hazard reporting</p>
          </div>
        </div>
        
        <div class="col-md-4">
          <div class="feature-card glass-card">
            <div class="feature-icon">
              <i class="fas fa-cloud"></i>
            </div>
            <h3 class="feature-title">Cloud Storage</h3>
            <p class="feature-description">Secure cloud storage ensures your reports are always accessible</p>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- Stats Section -->
  <section class="stats-section">
    <div class="container">
      <div class="row g-4 text-center">
        <div class="col-md-3">
          <div class="stat-item">
            <div class="stat-number" data-count="1250">0</div>
            <div class="stat-label">Hazards Detected</div>
          </div>
        </div>
        
        <div class="col-md-3">
          <div class="stat-item">
            <div class="stat-number" data-count="98">0</div>
            <div class="stat-label">Accuracy Rate (%)</div>
          </div>
        </div>
        
        <div class="col-md-3">
          <div class="stat-item">
            <div class="stat-number" data-count="45">0</div>
            <div class="stat-label">Cities Covered</div>
          </div>
        </div>
        
        <div class="col-md-3">
          <div class="stat-item">
            <div class="stat-number" data-count="2400">0</div>
            <div class="stat-label">Active Users</div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- CTA Section -->
  <section class="cta-section">
    <div class="container text-center">
      <h2>Ready to Make Roads Safer?</h2>
      <p class="lead">Join thousands of users helping to create safer roads through AI-powered hazard detection</p>
      <div class="action-group">
        <a href="/pages/camera.html" class="btn btn-primary btn-lg">
          <i class="fas fa-play"></i> Get Started
        </a>
        <a href="/pages/dashboard.html" class="btn btn-glass btn-lg">
          <i class="fas fa-info-circle"></i> Learn More
        </a>
      </div>
    </div>
  </section>
  <script>
    (function() {
      const settings = JSON.parse(localStorage.getItem('design-settings') || '{}');
      Object.entries(settings).forEach(([key, value]) => {
        if (key === 'theme-mode') {
          if (value === 'light') {
            document.documentElement.style.setProperty('--bg-main', '#f8fafc');
            document.documentElement.style.setProperty('--text-primary', '#1a1f2e');
          } else {
            document.documentElement.style.setProperty('--bg-main', '#0a0e1a');
            document.documentElement.style.setProperty('--text-primary', '#f8fafc');
          }
        } else {
          document.documentElement.style.setProperty(`--${key}`, value);
        }
      });
    })();
  </script>
  <script>
    // Counter animation
    function animateCounters() {
      const counters = document.querySelectorAll('[data-count]');
      
      counters.forEach(counter => {
        const target = parseInt(counter.getAttribute('data-count'));
        const duration = 2000;
        const increment = target / (duration / 16);
        let current = 0;
        
        const timer = setInterval(() => {
          current += increment;
          if (current >= target) {
            current = target;
            clearInterval(timer);
          }
          counter.textContent = Math.floor(current);
        }, 16);
      });
    }

    // Real AI Detection functionality using ONNX model
    function initDemoUpload() {
      const uploadArea = document.getElementById('upload-area');
      const uploadInput = document.getElementById('demo-upload');
      const demoBtn = document.getElementById('demo-upload-btn');
      const demoResults = document.getElementById('demo-results');
      const demoCanvas = document.getElementById('demo-canvas');
      const saveReportSection = document.getElementById('save-report-section');
      const saveReportBtn = document.getElementById('save-report-btn');
      const modelLoading = document.getElementById('model-loading');
      const ctx = demoCanvas.getContext('2d');

      // AI Model variables
      let session = null;
      let currentImage = null;
      let detectedHazards = [];
      let geoData = null;
      const FIXED_SIZE = 640;
      const classNames = ['crack', 'knocked', 'pothole', 'surface_damage'];
      let confidenceThreshold = 0.5;

      // Initialize model loading
      loadAIModel();

      async function loadAIModel() {
        try {
          modelLoading.style.display = 'block';
          
          // Wait for ONNX Runtime
          await waitForOrt();
          
          const ort = window.ort;
          ort.env.wasm.wasmPaths = "/assets/ort/";
          ort.env.wasm.simd = true;
          ort.env.wasm.numThreads = Math.min(navigator.hardwareConcurrency || 1, 2);
          ort.env.logLevel = 'warning';
          
          const sessionOptions = {
            executionProviders: ["wasm"],
            graphOptimizationLevel: "all",
            enableCpuMemArena: true,
            enableMemPattern: true,
            executionMode: "sequential",
            intraOpNumThreads: 1
          };
          
          console.log("Loading AI model for demo detection...");
          session = await ort.InferenceSession.create(
            "/assets/object_detecion_model/model 18:7.onnx",
            sessionOptions
          );
          
          console.log("✅ AI Model loaded successfully for demo");
          modelLoading.style.display = 'none';
          
          // Warm up the model
          const dummyInput = new ort.Tensor('float32', new Float32Array(3 * FIXED_SIZE * FIXED_SIZE), [1, 3, FIXED_SIZE, FIXED_SIZE]);
          await session.run({ images: dummyInput });
          dummyInput.dispose?.();
          
        } catch (error) {
          console.error("Failed to load AI model:", error);
          modelLoading.innerHTML = '<p class="text-danger">⚠️ Failed to load AI model. Demo detection unavailable.</p>';
        }
      }

      function waitForOrt() {
        return new Promise((resolve, reject) => {
          let attempts = 0;
          const maxAttempts = 100;
          
          const checkOrt = () => {
            if (window.ort && window.ort.env && window.ort.InferenceSession) {
              resolve(window.ort);
            } else if (attempts < maxAttempts) {
              attempts++;
              setTimeout(checkOrt, 100);
            } else {
              reject(new Error("ONNX Runtime failed to load"));
            }
          };
          
          checkOrt();
        });
      }

      // Click handlers
      uploadArea.addEventListener('click', () => uploadInput.click());
      demoBtn.addEventListener('click', () => uploadInput.click());

      // Drag and drop
      uploadArea.addEventListener('dragover', (e) => {
        e.preventDefault();
        uploadArea.classList.add('dragover');
      });

      uploadArea.addEventListener('dragleave', () => {
        uploadArea.classList.remove('dragover');
      });

      uploadArea.addEventListener('drop', (e) => {
        e.preventDefault();
        uploadArea.classList.remove('dragover');
        const file = e.dataTransfer.files[0];
        if (file && file.type.startsWith('image/')) {
          processImageWithAI(file);
        }
      });

      // File input change
      uploadInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
          processImageWithAI(file);
        }
      });

      // Confidence slider
      const confSlider = document.getElementById('demo-confidence-slider');
      const confValue = document.getElementById('demo-conf-value');
      confSlider.addEventListener('input', (e) => {
        confidenceThreshold = parseFloat(e.target.value);
        confValue.textContent = confidenceThreshold;
        if (currentImage && session) {
          runAIDetection(currentImage);
        }
      });

      async function processImageWithAI(file) {
        if (!session) {
          alert('AI model is still loading. Please wait...');
          return;
        }

        console.log('Processing image with AI detection...');
        geoData = null; // Reset geo data

        // Priority 1: Try to get geolocation from image EXIF first
        console.log('🔍 Attempting to extract location from image metadata...');
        try {
          const exifLocation = await getGeoDataFromImage(file);
          if (exifLocation) {
            geoData = JSON.stringify(exifLocation);
            console.log('✅ Using location from image metadata:', exifLocation);
          } else {
            console.log('ℹ️ No location found in image metadata');
          }
        } catch (error) {
          console.warn('Failed to extract EXIF location:', error);
        }

        // Priority 2: If no EXIF geo data, try to get current location
        if (!geoData && navigator.geolocation) {
          console.log('📍 Attempting to get current GPS location...');
          try {
            const position = await getCurrentPosition();
            geoData = JSON.stringify({
              lat: position.coords.latitude,
              lng: position.coords.longitude
            });
            console.log('✅ Using current GPS location');
          } catch (error) {
            console.warn('Could not get current location:', error);
            
            // Show user-friendly message about location
            if (error.code === 1) {
              console.log('📷 Location permission denied - reports will use image metadata only');
            }
          }
        }

        // Inform user about location status
        if (!geoData) {
          console.warn('⚠️ No location data available - reports may not be saved with location info');
        }

        const reader = new FileReader();
        reader.onload = (e) => {
          const img = new Image();
          img.onload = async () => {
            currentImage = img;
            demoCanvas.width = FIXED_SIZE;
            demoCanvas.height = FIXED_SIZE;
            
            demoResults.style.display = 'block';
            demoResults.scrollIntoView({ behavior: 'smooth' });
            
            await runAIDetection(img);
          };
          img.src = e.target.result;
        };
        reader.readAsDataURL(file);
      }

      function getCurrentPosition() {
        return new Promise((resolve, reject) => {
          navigator.geolocation.getCurrentPosition(resolve, reject);
        });
      }

      async function getGeoDataFromImage(file) {
        return new Promise((resolve, reject) => {
          if (!window.EXIF) {
            console.warn('EXIF.js not loaded, cannot extract location from image');
            resolve(null);
            return;
          }

          const reader = new FileReader();
          reader.onload = function (e) {
            const img = new Image();
            img.onload = function () {
              EXIF.getData(img, function () {
                try {
                  const lat = EXIF.getTag(this, "GPSLatitude");
                  const lon = EXIF.getTag(this, "GPSLongitude");
                  const latRef = EXIF.getTag(this, "GPSLatitudeRef") || "N";
                  const lonRef = EXIF.getTag(this, "GPSLongitudeRef") || "E";

                  console.log('EXIF GPS data found:', { lat, lon, latRef, lonRef });

                  if (!lat || !lon) {
                    console.log('No GPS coordinates found in image EXIF data');
                    resolve(null);
                    return;
                  }

                  // Convert DMS (Degrees, Minutes, Seconds) to decimal degrees
                  const toDecimal = (dms, ref) => {
                    if (!Array.isArray(dms) || dms.length !== 3) {
                      console.warn('Invalid DMS format:', dms);
                      return null;
                    }
                    const [deg, min, sec] = dms;
                    let decimal = deg + min / 60 + sec / 3600;
                    if (ref === "S" || ref === "W") decimal *= -1;
                    return decimal;
                  };

                  const latitude = toDecimal(lat, latRef);
                  const longitude = toDecimal(lon, lonRef);

                  if (latitude === null || longitude === null) {
                    console.warn('Failed to convert GPS coordinates');
                    resolve(null);
                    return;
                  }

                  // Validate coordinates
                  if (latitude < -90 || latitude > 90 || longitude < -180 || longitude > 180) {
                    console.warn('Invalid GPS coordinates:', { latitude, longitude });
                    resolve(null);
                    return;
                  }

                  console.log('✅ Successfully extracted location from image EXIF:', { lat: latitude, lng: longitude });
                  resolve({ lat: latitude, lng: longitude });
                } catch (error) {
                  console.error('Error extracting EXIF GPS data:', error);
                  resolve(null);
                }
              });
            };
            img.onerror = () => {
              console.error('Failed to load image for EXIF extraction');
              resolve(null);
            };
            img.src = e.target.result;
          };
          reader.onerror = () => {
            console.error('Failed to read file for EXIF extraction');
            resolve(null);
          };
          reader.readAsDataURL(file);
        });
      }

      async function runAIDetection(imageElement) {
        try {
          // Prepare image for model
          const offscreen = document.createElement("canvas");
          offscreen.width = FIXED_SIZE;
          offscreen.height = FIXED_SIZE;
          const offCtx = offscreen.getContext("2d");

          const imgW = imageElement.width;
          const imgH = imageElement.height;
          const scale = Math.min(FIXED_SIZE / imgW, FIXED_SIZE / imgH);
          const newW = Math.round(imgW * scale);
          const newH = Math.round(imgH * scale);
          const offsetX = Math.floor((FIXED_SIZE - newW) / 2);
          const offsetY = Math.floor((FIXED_SIZE - newH) / 2);

          offCtx.fillStyle = "black";
          offCtx.fillRect(0, 0, FIXED_SIZE, FIXED_SIZE);
          offCtx.drawImage(imageElement, offsetX, offsetY, newW, newH);

          const imageData = offCtx.getImageData(0, 0, FIXED_SIZE, FIXED_SIZE);
          const { data, width, height } = imageData;

          // Convert to tensor format
          const tensorData = new Float32Array(width * height * 3);
          for (let i = 0, j = 0; i < data.length; i += 4, j += 3) {
            tensorData[j] = data[i] / 255;
            tensorData[j + 1] = data[i + 1] / 255;
            tensorData[j + 2] = data[i + 2] / 255;
          }

          const chwData = new Float32Array(3 * width * height);
          for (let c = 0; c < 3; c++) {
            for (let h = 0; h < height; h++) {
              for (let w = 0; w < width; w++) {
                chwData[c * width * height + h * width + w] =
                  tensorData[h * width * 3 + w * 3 + c];
              }
            }
          }

          const tensor = new window.ort.Tensor("float32", chwData, [1, 3, height, width]);
          const feeds = { images: tensor };

          // Run inference
          const results = await session.run(feeds);
          const outputKey = Object.keys(results)[0];
          const outputData = results[outputKey].data;

          // Clean up tensors
          tensor.dispose?.();
          Object.values(results).forEach((tensor) => tensor.dispose?.());

          // Parse results
          const boxes = [];
          for (let i = 0; i < outputData.length; i += 6) {
            const box = outputData.slice(i, i + 6);
            boxes.push(box);
          }

          drawDetectionResults(boxes, { offsetX, offsetY, newW, newH });

        } catch (error) {
          console.error("AI Detection failed:", error);
          alert("Detection failed: " + error.message);
        }
      }

      function drawDetectionResults(boxes, letterboxParams) {
        detectedHazards = [];
        ctx.clearRect(0, 0, demoCanvas.width, demoCanvas.height);
        const { offsetX, offsetY, newW, newH } = letterboxParams;

        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, FIXED_SIZE, FIXED_SIZE);

        if (currentImage) {
          ctx.drawImage(currentImage, offsetX, offsetY, newW, newH);
        }

        let hasDetections = false;

        boxes.forEach((box) => {
          let [x1, y1, x2, y2, score, classId] = box;
          if (score < confidenceThreshold) return;

          const boxW = x2 - x1;
          const boxH = y2 - y1;

          if (boxW <= 1 || boxH <= 1 || boxW > FIXED_SIZE || boxH > FIXED_SIZE) return;

          hasDetections = true;
          const labelName = classNames[Math.floor(classId)] || `Class ${classId}`;
          const scorePerc = (score * 100).toFixed(1);

          if (!detectedHazards.includes(labelName)) {
            detectedHazards.push(labelName);
          }

          // Draw detection box
          ctx.strokeStyle = "#00FF00";
          ctx.lineWidth = 3;
          ctx.strokeRect(x1, y1, boxW, boxH);

          // Draw label
          ctx.fillStyle = "#00FF00";
          ctx.font = "bold 16px Arial";
          const textWidth = ctx.measureText(`${labelName} (${scorePerc}%)`).width;
          const textBgX = x1;
          const textBgY = y1 > 20 ? y1 - 20 : y1;
          ctx.fillRect(textBgX, textBgY, textWidth + 8, 20);
          ctx.fillStyle = "black";
          ctx.fillText(`${labelName} (${scorePerc}%)`, textBgX + 4, textBgY + 15);
        });

        // Show/hide save report button based on detections
        if (hasDetections && detectedHazards.length > 0) {
          saveReportSection.style.display = 'block';
        } else {
          saveReportSection.style.display = 'none';
        }
      }

      // Save report functionality
      saveReportBtn.addEventListener('click', async () => {
        if (!currentImage || detectedHazards.length === 0) {
          alert('No hazards detected to save as report');
          return;
        }

        if (!geoData) {
          alert('Cannot create report without location data');
          return;
        }

        try {
          // Convert canvas to blob
          demoCanvas.toBlob(async (blob) => {
            const file = new File([blob], "detection_report.jpg", { type: "image/jpeg" });
            const formData = new FormData();
            formData.append("file", file);
            formData.append("geoData", geoData);
            formData.append("hazardTypes", detectedHazards.join(","));
            formData.append("locationNote", "Demo Upload");

            try {
              const response = await fetch('/api/detections', {
                method: 'POST',
                body: formData,
                credentials: 'include'
              });

              if (response.ok) {
                const result = await response.json();
                alert('✅ Report saved successfully!\nReport ID: ' + (result.reportId || 'Unknown'));
                
                // Clear the demo
                currentImage = null;
                detectedHazards = [];
                demoResults.style.display = 'none';
                uploadInput.value = '';
              } else {
                const error = await response.json();
                alert('❌ Failed to save report: ' + (error.error || 'Unknown error'));
              }
            } catch (error) {
              console.error('Save report error:', error);
              alert('❌ Failed to save report: ' + error.message);
            }
          }, "image/jpeg", 0.95);

        } catch (error) {
          console.error('Report creation error:', error);
          alert('❌ Failed to create report: ' + error.message);
        }
      });
    }

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', () => {
      // Animate counters when they come into view
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            animateCounters();
            observer.disconnect();
          }
        });
      });
      
      const statsSection = document.querySelector('.stats-section');
      if (statsSection) {
        observer.observe(statsSection);
      }
      
      // Initialize demo upload
      initDemoUpload();
      
      // Initialize demo confidence slider
      const demoConfSlider = document.getElementById('demo-confidence-slider');
      const demoConfValue = document.getElementById('demo-conf-value');
      if (demoConfSlider && demoConfValue) {
        demoConfSlider.addEventListener('input', (e) => {
          demoConfValue.textContent = e.target.value;
          // Re-run detection with new confidence if image is loaded
          // This would require storing the last processed results
        });
      }
    });
  </script>
  <!-- EXIF.js for image metadata extraction -->
  <script src="https://cdn.jsdelivr.net/npm/exif-js@2.3.0/exif.js"></script>
  
  <!-- ONNX Runtime -->
  <script src="/assets/ort/ort.min.js" onload="console.log('ONNX Runtime loaded for demo detection'); if(window.ort) { window.ort.env.wasm.wasmPaths = '/assets/ort/'; }" onerror="console.error('Failed to load ONNX Runtime')"></script>
  
  <!-- Load Unified Navigation -->
  <script>
    // Load unified navigation component
    fetch('/components/navigation/unified-nav.html')
      .then(response => response.text())
      .then(html => {
        document.getElementById('unified-navigation-container').innerHTML = html;
        // Load navigation JavaScript
        const script = document.createElement('script');
        script.src = '/components/navigation/unified-nav.js';
        document.head.appendChild(script);
      })
      .catch(error => console.error('Error loading navigation:', error));
  </script>
</body>
</html>